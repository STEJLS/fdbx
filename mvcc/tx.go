package mvcc

import (
	"encoding/binary"
	"sync/atomic"
	"time"

	fbs "github.com/google/flatbuffers/go"
	"github.com/google/uuid"
	"github.com/shestakovda/fdbx/models"
)

/*
	Begin - создание и старт новой транзакции MVCC поверх транзакций FDB.

	В первой транзакции мы создаем новый объект, после чего записываем его в новый случайный ключ.
	В момент записи FDB автоматически добавит в значение версию, которую и будем использовать для
	дальнейшей идентификации и кеширования статусов после фиксации.

	Вторая транзакция нужна, чтобы прочитать это значение, удалить его и записать объект как положено.

	Такая несколько схема кажется извращением, но она призвана одновременно достичь следующих целей:
	* Получить монотонно возрастающий идентификатор транзакции, синхронизированный между всеми инстансами
	* Не создать ни одного конфликта записи/чтения между параллельно стартующими транзакциями
*/
func Begin(conn db.Connection) (_ Tx, exp error) {
	t := &tx{
		conn:  conn,
		start: uint64(time.Now().UTC().UnixNano()),
	}

	uid := uuid.New()

	if exp = conn.Write(func(w db.Writer) error {
		return w.SetVersion(db.NewBytePair(nsTxTmp, uid[:]), nil)
	}); exp != nil {
		return ErrBegin.WithReason(err)
	}

	if exp = conn.Write(func(w db.Writer) (err error) {
		var ver db.Pair

		if ver, err = w.Pair(nsTxTmp, uid[:]); err != nil {
			return
		}

		t.txid = binary.BigEndian.Uint64(ver[:8])

		return w.SetPair(db.NewBytePair(nsTx, ver[:8], t.pack()))
	}); exp != nil {
		return ErrBegin.WithReason(exp)
	}

	return t, nil
}

type tx struct {
	start uint64
	txid  uint64
	opid  uint32
	conn  db.Connection
}

/*
	Select - выборка актуального в данной транзакции значения ключа.

	Каждый ключ для значения на самом деле хранится в нескольких версиях.
	Их можно разделить на три группы: устаревшие, актуальные, незакоммиченные.
	В каждый конкретный момент времени актуальной должна быть только 1 версия.
	Устаревших может быть очень много, это зависит от того, насколько часто объект
	меняется и как хорошо справляется сборщик мусора в БД (автовакуум). В обязанности
	сборщика входит очистка как удаленных версий, так и версий отклоненных транзакций.
	Кол-во незакоммиченных версий зависит от того, сколько транзакций открыто параллельно
	в данный момент.

	Мы должны выбрать все записанные в БД значения для данного ключа, чтобы проверить
	каждое и отклонить все неподходящие. Поскольку это происходит каждый раз, когда нам
	требуется какое-то значение, очевидно, что эффективность работы будет зависеть как
	от кол-ва параллельных запросов (нагрузки), так и от утилизации сборщика мусора.

	Поскольку мы храним список значений в порядке версий их создания, то мы можем
	перебирать значения-кандидаты от самых последних к самым старым. В этом случае
	степень влияния текущей нагрузки будет гораздо выше, чем эффективности сборщика.
	Это выгоднее, потому что если сборщик не справляется, то равномерно по всем ключам.
	А очень частые обновления при нагрузке идут только по некоторым из них, к тому же
	в реальных проектах процент таких ключей не должен быть высок, а нагрузка пиковая.

	Каждая запись содержит 4 служебных поля, определяющих её актуальность, попарно
	отвечающих за глобальную (между транзакциями) и локальную (в рамках транзакции)
	актуальность значений.

	Поскольку мы выбираем весь диапазон в рамках внутренней транзакции fdb, то при параллельных
	действиях в рамках этого диапазона (запись или изменение другой версии этого же значения)
	сработает внутренний механизм конфликтов fdb, так что одновременно двух актуальных
	версий не должно появиться. Один из обработчиков увидит изменения и изменит поведение.
*/
func (t *tx) Select(key Key) (Value, error) {
	var buf []byte

	// Получаем номер текущей операции
	// В случае конфликтов и повторов НЕ будет увеличиваться, и это правильно
	opid := atomic.AddUint32(&tx.op, 1)

	exp := t.conn.ReadOnly(func(r db.Reader) (err error) {
		var list []db.Pair

		// Локальный кеш статусов транзакций, чтобы не лазать 100500 раз по незавершенным
		// При конфликте и повторах инициализируется каждый раз заново, и это правильно!
		lc := newStatusCache()

		// Загружаем список версий, существующих в рамках этой операции
		if list, err = r.List(key, true); err != nil {
			return ErrSelect.WithReason(err)
		}

		// Проверяем все версии, пока не получим актуальную
		for i := range list {
			row := models.GetRootAsRow(list[i].Value, 0)

			// Частный случай - если запись создана в рамках текущей транзакции
			if xmin := row.XMin(); xmin == t.id {

				// Если запись создана позже в рамках данной транзакции, то еще не видна
				if row.CMin() >= opid {
					continue
				}

				// Поскольку данная транзакция еще не закоммичена, то версия может быть
				// Или удалена в этой же транзакции, или вообще не удалена (или 0, или t.id)
				// Если запись удалена в текущей транзакции и до этого момента, то уже не видна
				if row.XMax() == t.id && row.CMax() < opid {
					continue
				}

				// В этом случае объект создан в данной транзакции и еще не удален, можем прочитать
				buf = row.Value
				return nil
			} else if !t.isCommitted(lc, r, xmin) {
				// Если запись создана другой транзакцией и она еще не закоммичена, то еще не видна
				continue
			}

			// Проверяем, возможно запись уже была удалена
			switch xmax := row.XMax(); xmax {
			case t.id:
				// Если она была удалена до этого момента, то уже не видна
				if row.CMax() < opid {
					continue
				}

				// В этом случае объект создан в закоммиченной транзакции и удален позже, чем мы тут читаем
				fallthrough
			case 0:
				// В этом случае объект создан в закоммиченной транзакции и еще не был удален
				buf = row.Value
				return nil
			default:
				// Если запись была удалена другой транзакцией, но она еще закоммичена, то еще видна
				if !t.isCommitted(lc, r, xmax) {
					buf = row.Value
					return nil
				}
			}
		}
	})

	return nil, nil
}

func (t *tx) isCommitted(local *statusCache, r db.Reader, x uint64) bool {

	// Дешевле всего чекнуть в глобальном кеше, вдруг уже знаем такую
	if st := txCache.get(x); st != txStatusUnknown {
		return st == txStatusCommitted
	}

	// Возможно, это открытая транзакция из локального кеша
	if st := local.get(x); st != txStatusUnknown {
		return st == txStatusCommitted
	}

	// Придется слазать в БД за статусом и положить в кеш
	var txPair db.Pair

	// if txPair, err = r.Pair()

	return false
}

func (t *tx) pack() []byte {
	buf := fbs.NewBuilder(32)
	models.TransactionStart(buf)
	models.TransactionAddTxID(buf, t.txid)
	models.TransactionAddStart(buf, t.start)
	models.TransactionAddStatus(buf, t.status)
	buf.Finish(models.TransactionEnd(buf))
	return buf.FinishedBytes()
}
